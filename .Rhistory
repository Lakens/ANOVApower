meansplot2 = meansplot +
geom_point(position = position_dodge(width=0.9), shape = 10, size=5, stat="identity") + #Personal preference for sd -- ARC
geom_errorbar(aes(ymin = mu-sd, ymax = mu+sd),
position = position_dodge(width=0.9), size=.6, width=.3) +
coord_cartesian(ylim=c(min(mu)-sd, max(mu)+sd)) +
theme_bw() + ggtitle("Means for each condition in the design") +
scale_colour_brewer(palette = "Dark2")
}
if(plot == TRUE){
print(meansplot2)  #should be blocked in Shiny context
}
# Return results in list()
invisible(list(dataframe = dataframe,
design = design,
design_list = design_list,
factors = factors,
frml1 = frml1,
frml2 = frml2,
mu = mu,
sd = sd,
r = r,
n = n,
cor_mat = cor_mat,
sigmatrix = sigmatrix,
string = string,
labelnames = labelnameslist,
factornames = factornames,
meansplot = meansplot2))
}
exact_result <- ANOVA_exact(design_result, alpha_level = 0.05,
p_adjust = "none")
View(exact_result$dataframe)
exact_result$plot
ANOVA_exact <- function(design_result, alpha_level, p_adjust = "none",
seed = NULL, verbose = TRUE) {
if (is.element(p_adjust, c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")) == FALSE ) {
stop("p_adjust must be of an acceptable adjustment method: see ?p.adjust")
}
options(scipen = 999) # 'turn off' scientific notation
effect_size_d <- function(x, y, conf.level = 0.95){
sd1 <- sd(x) #standard deviation of measurement 1
sd2 <- sd(y) #standard deviation of measurement 2
n1 <- length(x) #number of pairs
n2 <- length(y) #number of pairs
df <- n1 + n2 - 2
m_diff <- mean(y - x)
sd_pooled <- (sqrt((((n1 - 1) * ((sd1^2))) + (n2 - 1) * ((sd2^2))) / ((n1 + n2 - 2)))) #pooled standard deviation
#Calculate Hedges' correction. Uses gamma, unless this yields a nan (huge n), then uses approximation
j <- (1 - 3/(4 * (n1 + n2 - 2) - 1))
t_value <- m_diff / sqrt(sd_pooled^2 / n1 + sd_pooled^2 / n2)
p_value = 2*pt(-abs(t_value),
df = df)
d <- m_diff / sd_pooled #Cohen's d
d_unb <- d*j #Hedges g, of unbiased d
invisible(list(d = d,
d_unb = d_unb,
p_value = p_value))
}
effect_size_d_paired <- function(x, y, conf.level = 0.95){
sd1 <- sd(x) #standard deviation of measurement 1
sd2 <- sd(y) #standard deviation of measurement 2
s_diff <- sd(x - y) #standard deviation of the difference scores
N <- length(x) #number of pairs
df = N - 1
s_av <- sqrt((sd1 ^ 2 + sd2 ^ 2) / 2) #averaged standard deviation of both measurements
#Cohen's d_av, using s_av as standardizer
m_diff <- mean(y - x)
d_av <- m_diff / s_av
d_av_unb <- (1 - (3 / (4 * (N - 1) - 1))) * d_av
#get the t-value for the CI
t_value <- m_diff / (s_diff / sqrt(N))
p_value = 2 * pt(-abs(t_value),
df = df)
#Cohen's d_z, using s_diff as standardizer
d_z <- t_value / sqrt(N)
d_z_unb <- (1 - (3 / (4 * (N - 1) - 1))) * d_z
invisible(list(
d_z = d_z,
d_z_unb = d_z_unb,
p_value = p_value
))
}
round_dig <- 4 #Set digits to which you want to round the output.
if (missing(alpha_level)) {
alpha_level <- 0.05
}
if (alpha_level >= 1 | alpha_level <= 0  ) {
stop("alpha_level must be less than 1 and greater than zero")
}
labelnameslist <- design_result$labelnames
factor_levels <- as.numeric(strsplit(design_result$string, "\\D+")[[1]])
string <- design_result$string #String used to specify the design
factornames <- design_result$factornames #Get factor names
# Specify the parameters you expect in your data (sd, r for within measures)
#number of subjects you will collect (for each between factor)
# For an all within design, this is total N
# For a 2b*2b design, this is the number of people in each between condition, so in each of 2*2 = 4 groups
n <- design_result$n
# specify population means for each condition (so 2 values for 2b design, 6 for 2b*3w, etc)
mu = design_result$mu # population means - should match up with the design
sd <- design_result$sd #population standard deviation (currently assumes equal variances)
r <- design_result$r # correlation between within factors (currently only 1 value can be entered)
###############
# 2. Create Dataframe based on Design ----
###############
#Count number of factors in design
factors <- design_result$factors
#Specify within/between factors in design: Factors that are within are 1, between 0
design <- design_result$design
sigmatrix <- design_result$sigmatrix
#Create the data frame. This will be re-used in the simulation (y variable is overwritten) but created only once to save time in the simulation
dataframe <- design_result$dataframe
###############
# 3. Specify factors for formula ----
###############
frml1 <- design_result$frml1
frml2 <- design_result$frml2
aov_result <- suppressMessages({aov_car(frml1, #here we use frml1 to enter formula 1 as designed above on the basis of the design
data = dataframe, include_aov = FALSE,
anova_table = list(es = "pes", p_adjust_method = p_adjust)) }) #This reports PES not GES
############################################
#Specify factors for formula ###############
design_list <- design_result$design_list
###############
# 5. Set up dataframe for simulation results
###############
#How many possible planned comparisons are there (to store p and es)
possible_pc <- (((prod(
as.numeric(strsplit(string, "\\D+")[[1]])
)) ^ 2) - prod(as.numeric(strsplit(string, "\\D+")[[1]])))/2
#create empty dataframe to store simulation results
#number of columns for ANOVA results and planned comparisons, times 2 (p-values and effect sizes)
sim_data <- as.data.frame(matrix(
ncol = 2 * (2 ^ factors - 1) + 2 * possible_pc,
nrow = 1
))
paired_tests <- combn(unique(dataframe$cond),2)
paired_p <- numeric(possible_pc)
paired_d <- numeric(possible_pc)
within_between <- sigmatrix[lower.tri(sigmatrix)] #based on whether correlation is 0 or not, we can determine if we should run a paired or independent t-test
#Dynamically create names for the data we will store
names(sim_data) = c(paste("anova_",
rownames(aov_result$anova_table),
sep = ""),
paste("anova_es_",
rownames(aov_result$anova_table),
sep = ""),
paste("p_",
paste(paired_tests[1,],paired_tests[2,],sep = "_"),
sep = ""),
paste("d_",
paste(paired_tests[1,],paired_tests[2,], sep = "_"),
sep = ""))
#We simulate a new y variable, melt it in long format, and add it to the dataframe (surpressing messages)
#empirical set to true to create "exact" dataset
set.seed(seed)
dataframe$y <- suppressMessages({
melt(as.data.frame(mvrnorm(
n = n,
mu = mu,
Sigma = as.matrix(sigmatrix),
empirical = TRUE
)))$value
})
#dataframe <- design_result$dataframe[,1:3]
#
#for(j in 1:factors){
#  dataframe <- cbind(dataframe, as.factor(unlist(rep(as.list(paste(labelnameslist[[j]],
#                                                                   sep="_")),
#                                                     each = n*prod(factor_levels)/prod(factor_levels[1:j]),
#                                                     times = prod(factor_levels)/prod(factor_levels[j:factors])
#  ))))
#}
#Rename the factor variables that were just created
#names(dataframe)[4:(3+factors)] <- factornames[1:factors]
# We perform the ANOVA using AFEX
#Can be set to NICE to speed up, but required data grabbing from output the change.
aov_result <- suppressMessages({aov_car(frml1, #here we use frml1 to enter fromula 1 as designed above on the basis of the design
data = dataframe, include_aov = FALSE, #Need development code to get aov_include function
anova_table = list(es = "pes",
p_adjust_method = p_adjust))}) #This reports PES not GES
for (j in 1:possible_pc) {
x <- dataframe$y[which(dataframe$cond == paired_tests[1,j])]
y <- dataframe$y[which(dataframe$cond == paired_tests[2,j])]
#this can be sped up by tweaking the functions that are loaded to only give p and dz
ifelse(within_between[j] == 0,
t_test_res <- effect_size_d(x, y, conf.level = 1 - alpha_level),
t_test_res <- effect_size_d_paired(x, y, conf.level = 1 - alpha_level))
paired_p[j] <- t_test_res$p_value
paired_d[j] <- ifelse(within_between[j] == 0,
t_test_res$d,
t_test_res$d_z)
}
# store p-values and effect sizes for calculations and plots.
sim_data <- c(aov_result$anova_table[[6]], #p-value for ANOVA
aov_result$anova_table[[5]], #partial eta squared
p.adjust(paired_p, method = p_adjust), #p-values for paired comparisons, added correction for multiple comparisons
paired_d) #effect sizes
###############
# 9. Sumary of power and effect sizes of main effects and contrasts ----
###############
#Main effects and interactions from the ANOVA
pvalue_anova = as.data.frame(apply(as.matrix(sim_data[(1:(2 ^ factors - 1))]), 2,
function(x) x))
es = as.data.frame(apply(as.matrix(sim_data[((2^factors):(2 * (2 ^ factors - 1)))]), 2,
function(x) round(x,round_dig)))
main_results <- data.frame(pvalue_anova,es)
names(main_results) = c("p_value","effect_size")
#Data summary for pairwise comparisons
pvalue_paired = as.data.frame(apply(as.matrix(sim_data[(2 * (2 ^ factors - 1) + 1):(2 * (2 ^ factors - 1) + possible_pc)]), 2,
function(x) x))
es_paired = as.data.frame(apply(as.matrix(sim_data[(2 * (2 ^ factors - 1) + possible_pc + 1):(2*(2 ^ factors - 1) + 2 * possible_pc)]), 2,
function(x) round(x,round_dig)))
pc_results <- data.frame(pvalue_paired, es_paired)
names(pc_results) = c("p_value","effect_size")
if (factors == 1) {meansplot = ggplot(dataframe, aes_string(y = "y", x = factornames[1]))}
if (factors == 2) {meansplot = ggplot(dataframe, aes_string(y = "y", x = factornames[1])) + facet_wrap(  paste("~",factornames[2],sep=""))}
if (factors == 3) {meansplot = ggplot(dataframe, aes_string(y = "y", x = factornames[1])) + facet_wrap(  paste("~",factornames[2],"*",factornames[3],sep=""))}
if (factors >= 2 && length(labelnameslist[[2]]) >= 9) {
meansplot2 = meansplot +
geom_jitter(position = position_jitter(0.2)) +
stat_summary(
fun.data = "mean_sdl",
fun.args = list(mult = 1),
geom = "crossbar",
color = "red"
) +
coord_cartesian(ylim = c(min(dataframe$y), max(dataframe$y))) +
theme_bw(base_size = 16) +
scale_colour_brewer(palette = "Dark2")
} else {
meansplot2 = meansplot +
geom_jitter(position = position_jitter(0.2)) +
stat_summary(
fun.data = "mean_sdl",
fun.args = list(mult = 1),
geom = "crossbar",
color = "red"
) +
coord_cartesian(ylim = c(min(dataframe$y), max(dataframe$y))) +
theme_bw()  +
scale_colour_brewer(palette = "Dark2")
}
# Return results in list()
invisible(list(dataframe = dataframe,
aov_result = aov_result,
main_results = main_results,
pc_results = pc_results,
p_adjust = p_adjust,
alpha_level = alpha_level,
plot = meansplot2))
}
exact_result <- ANOVA_exact(design_result, alpha_level = 0.05,
p_adjust = "none")
View(exact_result$dataframe)
exact_result$plot
exact_result$main_results
install.packages("roxygen2")
?mvrnorm
?expect_error
d <- ANOVA_design("2b*2b*2w", n = 10, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 10, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
exact_result$aov_result$anova_table
d <-  ANOVA_design(string = "2w*2w", n = 40, mu = c(1, 0, 1, 0), sd = 2, r = 0.8,
labelnames = c("condition", "cheerful", "sad", "voice", "human", "robot"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
exact_result$aov_result$anova_table
exact_result$plot
Anova_tab <- exact_result$aov_result$anova_table
class(Anova_tab)
Anova_tab <- as.data.frame(exact_result$aov_result$anova_table)
class(Anova_tab)
Anova_tab
colnames(Anova_tab) <- c("num_Df", "den_Df", "MSE", "F", "pes", "p")
Anova_tab
Anova_tab$f2 <- (Anova_tab$pes/(1-Anova_tab$pes))
Anova_tab
#Calculate noncentrality
Anova_tab$lambda <- Anova_tab$f2*Anova_tab$den_Df
Anova_tab
?qf
#Create dataframe from afex results
Anova_tab <- as.data.frame(exact_result$aov_result$anova_table)
colnames(Anova_tab) <- c("num_Df", "den_Df", "MSE", "F", "pes", "p")
#Calculate cohen's f
Anova_tab$f2 <- (Anova_tab$pes/(1-Anova_tab$pes))
#Calculate noncentrality
Anova_tab$lambda <- Anova_tab$f2*Anova_tab$den_Df
minusalpha<-1-alpha_level
Anova_tab$Ft <- qf(minusalpha, Anova_tab$num_Df, Anova_tab$den_Df)
#Calculate power
Anova_tab$power <- 1-pf(Anova_tab$Ft, Anova_tab$num_Df, Anova_tab$den_Df, Anova_tab$lambda)
alpha_level=.05
#Create dataframe from afex results
Anova_tab <- as.data.frame(exact_result$aov_result$anova_table)
colnames(Anova_tab) <- c("num_Df", "den_Df", "MSE", "F", "pes", "p")
#Calculate cohen's f
Anova_tab$f2 <- (Anova_tab$pes/(1-Anova_tab$pes))
#Calculate noncentrality
Anova_tab$lambda <- Anova_tab$f2*Anova_tab$den_Df
minusalpha<-1-alpha_level
Anova_tab$Ft <- qf(minusalpha, Anova_tab$num_Df, Anova_tab$den_Df)
#Calculate power
Anova_tab$power <- 1-pf(Anova_tab$Ft, Anova_tab$num_Df, Anova_tab$den_Df, Anova_tab$lambda)
View(Anova_tab)
p2 <- pwr::pwr.t.test(d = 2.2/6.4,
n = 100,
sig.level = 0.05,
type="two.sample",
alternative="two.sided")$power
p2
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
#Create dataframe from afex results
Anova_tab <- as.data.frame(exact_result$aov_result$anova_table)
colnames(Anova_tab) <- c("num_Df", "den_Df", "MSE", "F", "pes", "p")
#Calculate cohen's f
Anova_tab$f2 <- (Anova_tab$pes/(1-Anova_tab$pes))
#Calculate noncentrality
Anova_tab$lambda <- Anova_tab$f2*Anova_tab$den_Df
minusalpha<-1-alpha_level
Anova_tab$Ft <- qf(minusalpha, Anova_tab$num_Df, Anova_tab$den_Df)
#Calculate power
Anova_tab$power <- 1-pf(Anova_tab$Ft, Anova_tab$num_Df, Anova_tab$den_Df, Anova_tab$lambda)
exact_result$aov_result$anova_table[[6]]
Anova_tab[10]
main_res <- data.frame(Anova_tab$power, Anova_tab$pes)
main_res
rownames(Anova_tab)
main_result <- data.frame(Anova_tab$power, Anova_tab$pes)
rownames(main_result) <- rownames(Anova_tab)
main_result
library(ANOVApower)
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
exact_result$main_results
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
exact_result$main_results
?pt
?t.test
t.test(1:10, y = c(7:20, 200))
pt(-1.6329, df= 14.165)
pt(-1.6329, df= 14.165, lower.tail = FALSE)
?power.t.test
power.t.tes(n=10, delta = 40, sd = 50, type = "one.sample", alternative = "two.sided")
power.t.test(n=10, delta = 40, sd = 50, type = "one.sample", alternative = "two.sided")
pwr.test.1 <- power.t.test(n=10, delta = 40, sd = 50, type = "one.sample", alternative = "two.sided")
pwr.test.1$power
pwr.test.2 <- power.t.test(n=42, delta = 10, sd = 16.03, type = "two.sample", alternative = "two.sided")$power
pwr.test.2
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05,
p_adjust = "none")
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.0
5)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <-  ANOVA_design(string = "2b",
n = 100,
mu = c(24, 26.2),
sd = 6.4,
labelnames = c("condition", "control", "pet"),
plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
d <- ANOVA_design("2w*2b", n = 100, mu = 1:4, sd = 1, r = 0.5,
labelnames = c("W", "W1", "W2", "B", "B1", "B2"))
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.
0
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
power_result <- ANOVA_power(d, nsims = 10)
exact_result$pc_results
power_result$sim_data
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
exact_result$sim_data
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.
1
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <- ANOVA_design("2b*2b*2w", n = 100, mu = 1:8, sd = 1.5, r = .68)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
d <- ANOVA_design("2b", n = 100, mu = c(0,0), sd = 1, plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
d <- ANOVA_design("2b", n = 100, mu = c(0,0.5), sd = 1, plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
d <- ANOVA_design("2b", n = 100, mu = c(0,0.5), sd = 1, plot = FALSE)
exact_result <- ANOVA_exact(d, alpha_level = 0.05)
library(ANOVApower)
devtools::test()
?check
install.packages("roxygen2")
library(ANOVApower)
library(ANOVApower)
rmarkdown::pandoc_version()
local({
# The directory where Pandoc will be extracted. Feel free
# to adjust this path as appropriate.
dir <- "~/rstudio-pandoc"
# The version of Pandoc to be installed.
version <- "2.7.1"
# Create and move to the requested directory.
dir.create(dir, showWarnings = FALSE, recursive = TRUE)
owd <- setwd(dir)
on.exit(setwd(owd), add = TRUE)
# Construct path to pandoc.
root <- "https://s3.amazonaws.com/rstudio-buildtools"
suffix <- sprintf("pandoc-%s-windows-x86_64.zip", version)
url <- file.path(root, "pandoc-rstudio", version, suffix)
# Download and extract pandoc.
file <- basename(url)
utils::download.file(url, destfile = file)
utils::unzip(file)
unlink(file)
# Write .Renviron to update the version of Pandoc used.
entry <- paste("RSTUDIO_PANDOC", shQuote(path.expand(dir)), sep = " = ")
contents <- if (file.exists("~/.Renviron")) readLines("~/.Renviron")
filtered <- grep("^RSTUDIO_PANDOC", contents, value = TRUE, invert = TRUE)
amended <- union(filtered, entry)
writeLines(amended, "~/.Renviron")
# Report change to the user.
writeLines("Updated .Renviron:\n")
writeLines(amended)
writeLines("\nPlease restart RStudio for these changes to take effect.")
})
